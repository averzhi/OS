/*Программа состоит из двух функций: Square и Sort. Функция Square возвращает площадь прямоугольного треугольника с катетами A и B. 
Функция Sort сортирует массив целых чисел по возрастанию методом быстрой сортировки. Это значит, что она выбирает опорный элемент в массиве и разделяет 
массив на два отрезка: слева от опорного элемента все элементы меньше или равны ему, а справа - больше или равны. Затем она рекурсивно повторяет этот процесс
для каждого отрезка до тех пор, пока массив не будет полностью отсортирован. Этот алгоритм имеет сложность O(n log n), где n - размер массива.*/

// Объявление функции Square с внешним связыванием и параметрами типа float
extern "C" float Square(float A, float B);   
// Объявление функции Sort с внешним связыванием и параметром типа указатель на int
extern "C" int * Sort(int * array);         
using namespace std;

// Определение функции Square, которая возвращает площадь прямоугольного треугольника с катетами A и B
float Square(float A, float B)
{
    return (A*B)/2;
}

// Вспомогательная функция для сортировки массива по возрастанию методом быстрой сортировки
void _sort(int* a, int first, int last)
{
    // Инициализация индексов первого и последнего элементов отрезка массива
    int i = first, j = last;
    // Объявление переменной для обмена элементов и опорного элемента (среднего в отрезке)
    int tmp, x = a[(first + last) / 2];
    do 
    {
        // Поиск элемента большего или равного опорному слева от него
        while (a[i] < x)
        {
            i++;
        }
        // Поиск элемента меньшего или равного опорному справа от него
        while (a[j] > x)
        {
            j--;
        }
        // Если такие элементы найдены и не пересеклись
        if (i <= j) 
        {
            // Если они разные, то меняем их местами
            if (i < j)
            {
                tmp = a[i];
                a[i] = a[j];
                a[j] = tmp;
            }
            // Сдвигаем индексы на следующие позиции
            i++;
            j--;
        }
    } while (i <= j); // Повторяем цикл до тех пор, пока индексы не пересекутся
    // Если правый отрезок не пустой, то рекурсивно вызываем функцию для него
    if (i < last)
    {
        _sort(a, i, last);
    }
    // Если левый отрезок не пустой, то рекурсивно вызываем функцию для него
    if (first < j)
    {
        _sort(a, first, j);
    }
}

// Определение функции Sort, которая принимает указатель на массив целых чисел,
// где первый элемент - размер массива,
// и возвращает указатель на отсортированный массив по возрастанию 
int* Sort(int* array)
{
    _sort(array, 1, array[0]); // Вызов вспомогательной функции для всего массива кроме первого элемента 
    return array; // Возврат указателя на массив 
}
